<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>System Slicer PWA</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden; /* No scrolling allowed */
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* UPLOAD SCREEN */
    #uploadScreen {
      padding: 40px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      height: 100%;
    }
    .big-btn {
      background: #333;
      color: white;
      border: 2px solid #555;
      padding: 20px;
      font-size: 1.5rem;
      border-radius: 15px;
      margin: 20px 0;
    }

    /* THE STAGE */
    #performanceMode {
      display: none;
      flex: 1;
      position: relative;
      flex-direction: column;
    }

    #systemCanvas {
      width: 100%;
      height: 70vh; /* Takes up most of the screen */
      object-fit: contain; /* Ensures the system is fully visible */
      background: #fff; /* White background for the music itself */
      border-bottom: 5px solid #333;
    }

    /* CONTROLS */
    #controls {
      height: 30vh;
      display: flex;
      background: #111;
    }
    .nav-btn {
      flex: 1;
      font-size: 3rem;
      background: #222;
      color: #fff;
      border: 1px solid #444;
      active: background: #444;
    }
    #prevBtn { background: #1a1a1a; border-right: 1px solid #000; }
    #nextBtn { background: #004400; font-weight: bold; } /* Green tint for Next */

    /* LOADING OVERLAY */
    #loader {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      color: white;
      z-index: 100;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
    }
  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>Music Slicer</h1>
    <p>Upload a PDF. I will cut it into systems and show them one by one.</p>
    <input type="file" id="fileInput" accept="application/pdf" class="big-btn">
  </div>

  <div id="loader">Processing Score...<br><span style="font-size:1rem; color:#aaa">Scanning for staves</span></div>

  <div id="performanceMode">
    <canvas id="systemCanvas"></canvas>
    
    <div id="controls">
      <button id="prevBtn" class="nav-btn" onclick="prevSystem()">⬅️</button>
      <button id="nextBtn" class="nav-btn" onclick="nextSystem()">Next ➡️</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // CONFIG
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let allSystems = []; // Will hold {canvas, x, y, w, h} for every system found
    let currentSystemIndex = 0;
    const canvas = document.getElementById('systemCanvas');
    const ctx = canvas.getContext('2d');

    // 1. FILE HANDLING
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      document.getElementById('loader').style.display = 'flex';
      
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
      
      allSystems = []; // Reset
      
      // Process every page
      for (let p = 1; p <= pdf.numPages; p++) {
        await processPage(pdf, p);
      }

      // Done
      document.getElementById('loader').style.display = 'none';
      document.getElementById('uploadScreen').style.display = 'none';
      document.getElementById('performanceMode').style.display = 'flex';
      
      // Show first system
      currentSystemIndex = 0;
      renderSystem();
    });

    // 2. THE ALGORITHM (The "Slicer")
    async function processPage(pdf, pageNum) {
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale: 2.0 }); // High res for scanning
      
      // Create a temporary canvas to draw the full page
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      // GET PIXEL DATA
      const width = tempCanvas.width;
      const height = tempCanvas.height;
      const imageData = tempCtx.getImageData(0, 0, width, height).data;

      // SCAN LINES
      // We project the page onto the Y-axis (calculate 'darkness' of each row)
      let rowDensities = new Array(height).fill(0);
      
      for (let y = 0; y < height; y++) {
        // Sample every 10th pixel to save CPU
        let darkPixels = 0;
        for (let x = 0; x < width; x += 10) {
          const i = (y * width + x) * 4;
          const r = imageData[i];
          const g = imageData[i+1];
          const b = imageData[i+2];
          // If pixel is not white (assuming white background)
          if (r < 200 || g < 200 || b < 200) {
            darkPixels++;
          }
        }
        rowDensities[y] = darkPixels;
      }

      // IDENTIFY SYSTEMS
      // We look for clusters of "dark rows" separated by "light rows"
      const THRESHOLD = 5; // Min dark pixels to count as 'content'
      const MIN_SYSTEM_HEIGHT = 50; // Ignore tiny specks
      const GAP_TOLERANCE = 30; // How much white space allowed *inside* a system (e.g. between treble/bass clef)

      let systems = [];
      let inSystem = false;
      let startY = 0;
      let whiteSpaceCounter = 0;

      for (let y = 0; y < height; y++) {
        const isContent = rowDensities[y] > THRESHOLD;

        if (isContent) {
          if (!inSystem) {
            inSystem = true;
            startY = y;
          }
          whiteSpaceCounter = 0; // Reset gap counter
        } else {
          if (inSystem) {
            whiteSpaceCounter++;
            // If we see too much white space, close the system
            if (whiteSpaceCounter > GAP_TOLERANCE) {
              inSystem = false;
              let endY = y - whiteSpaceCounter; // Backtrack to where content actually ended
              
              if ((endY - startY) > MIN_SYSTEM_HEIGHT) {
                // Found a valid system!
                // Add some padding
                systems.push({
                  sourceCanvas: tempCanvas,
                  y: Math.max(0, startY - 20),
                  h: Math.min(height, (endY - startY) + 40),
                  w: width
                });
              }
            }
          }
        }
      }
      
      // If page ends while in a system
      if (inSystem && (height - startY) > MIN_SYSTEM_HEIGHT) {
        systems.push({
          sourceCanvas: tempCanvas,
          y: Math.max(0, startY - 20),
          h: (height - startY) + 20,
          w: width
        });
      }

      allSystems.push(...systems);
    }

    // 3. THE PROJECTOR (Renderer)
    function renderSystem() {
      if (allSystems.length === 0) return;
      
      const sys = allSystems[currentSystemIndex];
      
      // Resize display canvas to match aspect ratio of the cut
      // Actually, we want to fill the screen width, and let height adjust
      canvas.width = sys.w;
      canvas.height = sys.h;

      // Draw just that slice
      ctx.fillStyle = "white";
      ctx.fillRect(0,0, canvas.width, canvas.height);
      ctx.drawImage(
        sys.sourceCanvas, 
        0, sys.y, sys.w, sys.h, // Source coords
        0, 0, sys.w, sys.h      // Dest coords
      );
    }

    // 4. NAVIGATION
    function nextSystem() {
      if (currentSystemIndex < allSystems.length - 1) {
        currentSystemIndex++;
        renderSystem();
      }
    }

    function prevSystem() {
      if (currentSystemIndex > 0) {
        currentSystemIndex--;
        renderSystem();
      }
    }

    // Keyboard support (Spacebar / Arrows)
    window.addEventListener('keydown', (e) => {
      if (e.key === "ArrowRight" || e.key === " ") {
        nextSystem();
      } else if (e.key === "ArrowLeft") {
        prevSystem();
      }
    });

  </script>
</body>
</html>
