<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Precision Cropper</title>
  <style>
    /* 1. RESET & LAYOUT */
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden; /* Prevent body scroll, we handle it internally */
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .hidden { display: none !important; }

    /* 2. UPLOAD SCREEN */
    #uploadScreen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      text-align: center;
    }
    .big-file-btn {
      margin-top: 20px;
      padding: 15px;
      background: #333;
      border: 2px dashed #666;
      color: #fff;
      border-radius: 10px;
    }

    /* 3. EDITOR SCREEN */
    #editorScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* Sticky Header */
    #editorToolbar {
      height: 60px;
      background: #222;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 15px;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    .tool-btn {
      background: #444;
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .primary-btn { background: #0066cc; }
    .success-btn { background: #008800; }
    
    #editorScrollArea {
      flex: 1;
      overflow: auto; /* Allow scrolling the PDF */
      position: relative;
      background: #333;
      touch-action: pan-y; /* Allow vertical scroll, but we override for drawing */
    }

    /* The Drawing Surface */
    #editorCanvas {
      display: block;
      margin: 0 auto;
      background: white;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      /* CRITICAL: Disables default touch actions so we can draw */
      touch-action: none; 
    }

    /* 4. PERFORMANCE SCREEN */
    #performanceScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #000;
    }
    
    #slideContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
    }
    
    #slideCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: white; /* Paper color */
    }

    #navControls {
      height: 15vh;
      display: flex;
      background: #111;
      border-top: 1px solid #333;
    }
    .nav-btn {
      flex: 1;
      font-size: 2rem;
      background: #111;
      color: #fff;
      border: none;
      border-right: 1px solid #333;
    }
    .nav-btn:active { background: #222; }

  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>Manual System Cropper</h1>
    <p style="color:#aaa;">Upload PDF &rarr; Draw Boxes &rarr; Play</p>
    <input type="file" id="fileInput" accept="application/pdf" class="big-file-btn">
  </div>

  <div id="editorScreen" class="hidden">
    <div id="editorToolbar">
      <div id="pageInfo" style="font-weight:bold;">Page 1</div>
      <div style="display:flex; gap:10px;">
        <button class="tool-btn" onclick="undoBox()">Undo</button>
        <button class="tool-btn primary-btn" onclick="nextPage()">Next Pg &rarr;</button>
        <button class="tool-btn success-btn" onclick="finishEditing()">Play &#9658;</button>
      </div>
    </div>
    <div id="editorScrollArea">
      <canvas id="editorCanvas"></canvas>
    </div>
  </div>

  <div id="performanceScreen" class="hidden">
    <div id="slideContainer">
      <canvas id="slideCanvas"></canvas>
    </div>
    <div id="navControls">
      <button class="nav-btn" onclick="prevSlide()">&#8592;</button>
      <button class="nav-btn" onclick="nextSlide()" style="background:#003300; font-weight:bold;">Next &#8594;</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // --- 1. SETUP ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    let pdfDoc = null;
    let pageNum = 1;
    let allCroppings = []; // { page: 1, x, y, w, h }
    let currentBoxes = []; // Boxes for the current page being edited
    let playIndex = 0;

    // DOM Elements
    const editorCanvas = document.getElementById('editorCanvas');
    const ctx = editorCanvas.getContext('2d');
    const slideCanvas = document.getElementById('slideCanvas');
    const slideCtx = slideCanvas.getContext('2d');

    // --- 2. FILE UPLOAD ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if(!file) return;

      const buffer = await file.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument(buffer).promise;

      document.getElementById('uploadScreen').classList.add('hidden');
      document.getElementById('editorScreen').classList.remove('hidden');
      
      loadEditorPage(1);
    });

    // --- 3. EDITOR LOGIC ---
    async function loadEditorPage(num) {
      if(num > pdfDoc.numPages) {
        finishEditing(); // Auto-finish if no more pages
        return;
      }
      pageNum = num;
      currentBoxes = []; // Clear boxes for new page
      document.getElementById('pageInfo').innerText = `Page ${num} / ${pdfDoc.numPages}`;

      const page = await pdfDoc.getPage(num);
      // Use scale 1.5 for a crisp editor view on iPad
      const viewport = page.getViewport({ scale: 1.5 });

      editorCanvas.width = viewport.width;
      editorCanvas.height = viewport.height;
      
      // Render the PDF to the canvas
      await page.render({ canvasContext: ctx, viewport }).promise;

      // Save the "Clean" background for redraws
      editorCanvas.dataset.clean = editorCanvas.toDataURL();
    }

    function redraw() {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0,0, editorCanvas.width, editorCanvas.height);
        ctx.drawImage(img, 0, 0);

        // Draw saved boxes
        currentBoxes.forEach((box, i) => {
          ctx.strokeStyle = '#00ff00';
          ctx.lineWidth = 3;
          ctx.strokeRect(box.x, box.y, box.w, box.h);
          ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
          ctx.fillRect(box.x, box.y, box.w, box.h);
          
          // Draw Number
          ctx.fillStyle = '#000';
          ctx.fillRect(box.x, box.y, 20, 20);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 14px Arial';
          ctx.fillText(i+1, box.x+5, box.y+15);
        });

        // Draw Active Drag Box
        if(isDragging) {
           const w = currentX - startX;
           const h = currentY - startY;
           ctx.strokeStyle = 'yellow';
           ctx.lineWidth = 2;
           ctx.strokeRect(startX, startY, w, h);
        }
      };
      img.src = editorCanvas.dataset.clean;
    }

    // --- 4. TOUCH & DRAWING ENGINE (The Fix) ---
    let isDragging = false;
    let startX = 0, startY = 0;
    let currentX = 0, currentY = 0;

    // THE MAGIC FUNCTION: Maps screen pixels to canvas pixels accurately
    function getPos(e) {
      const rect = editorCanvas.getBoundingClientRect();
      
      // Handle Touch vs Mouse
      let cx = e.clientX;
      let cy = e.clientY;
      if(e.changedTouches && e.changedTouches.length > 0) {
        cx = e.changedTouches[0].clientX;
        cy = e.changedTouches[0].clientY;
      }

      // Calculate Scaling Ratio
      // (Internal Resolution / Screen Size)
      const scaleX = editorCanvas.width / rect.width;
      const scaleY = editorCanvas.height / rect.height;

      return {
        x: (cx - rect.left) * scaleX,
        y: (cy - rect.top) * scaleY
      };
    }

    // START
    const startDraw = (e) => {
      // Allow multi-touch for zooming, only draw with 1 finger
      if(e.touches && e.touches.length > 1) return;
      
      e.preventDefault(); // Stop Scroll
      const pos = getPos(e);
      startX = pos.x;
      startY = pos.y;
      isDragging = true;
    };

    // MOVE
    const moveDraw = (e) => {
      if(!isDragging) return;
      e.preventDefault(); // Stop Scroll
      const pos = getPos(e);
      currentX = pos.x;
      currentY = pos.y;
      redraw();
    };

    // END
    const endDraw = (e) => {
      if(!isDragging) return;
      e.preventDefault();
      isDragging = false;

      // Recalc final pos
      const pos = getPos(e);
      currentX = pos.x;
      currentY = pos.y;
      
      const w = currentX - startX;
      const h = currentY - startY;

      // Only add if box is bigger than 20x20px (prevents accidental dots)
      if(Math.abs(w) > 20 && Math.abs(h) > 20) {
        // Normalize negatives (dragging up/left)
        const finalX = w < 0 ? currentX : startX;
        const finalY = h < 0 ? currentY : startY;
        const finalW = Math.abs(w);
        const finalH = Math.abs(h);

        currentBoxes.push({ x: finalX, y: finalY, w: finalW, h: finalH });
      }
      redraw();
    };
    
    // Double Tap to Delete Logic
    editorCanvas.addEventListener('dblclick', (e) => {
       const pos = getPos(e);
       // Find if we clicked inside a box (iterate backwards to get top-most)
       for(let i = currentBoxes.length - 1; i >= 0; i--) {
         const b = currentBoxes[i];
         if(pos.x >= b.x && pos.x <= b.x + b.w && pos.y >= b.y && pos.y <= b.y + b.h) {
           currentBoxes.splice(i, 1); // Remove it
           redraw();
           break;
         }
       }
    });

    editorCanvas.addEventListener('mousedown', startDraw);
    editorCanvas.addEventListener('mousemove', moveDraw);
    editorCanvas.addEventListener('mouseup', endDraw);
    
    editorCanvas.addEventListener('touchstart', startDraw, {passive: false});
    editorCanvas.addEventListener('touchmove', moveDraw, {passive: false});
    editorCanvas.addEventListener('touchend', endDraw, {passive: false});


    // --- 5. BUTTON ACTIONS ---
    function undoBox() {
      currentBoxes.pop();
      redraw();
    }

    function nextPage() {
      // 1. Save current boxes to Master List
      currentBoxes.forEach(b => {
        allCroppings.push({
          pageNum: pageNum,
          x: b.x, y: b.y, w: b.w, h: b.h
        });
      });
      
      // 2. Load next
      loadEditorPage(pageNum + 1);
    }

    function finishEditing() {
      // Save any current boxes first
      currentBoxes.forEach(b => {
        allCroppings.push({
          pageNum: pageNum,
          x: b.x, y: b.y, w: b.w, h: b.h
        });
      });

      if(allCroppings.length === 0) {
        alert("No boxes drawn!");
        return;
      }

      // Switch UI
      document.getElementById('editorScreen').classList.add('hidden');
      document.getElementById('performanceScreen').classList.remove('hidden');
      
      playIndex = 0;
      renderSlide();
    }

    // --- 6. PLAYER ENGINE ---
    async function renderSlide() {
      const crop = allCroppings[playIndex];
      
      // We need to fetch the page again to render the clean crop
      const page = await pdfDoc.getPage(crop.pageNum);
      const viewport = page.getViewport({ scale: 1.5 }); // Match editor scale

      // Temporary canvas to hold the full page
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      // Draw just the cropped region to the slide canvas
      slideCanvas.width = crop.w;
      slideCanvas.height = crop.h;
      
      slideCtx.fillStyle = "white";
      slideCtx.fillRect(0,0, crop.w, crop.h);
      
      slideCtx.drawImage(
        tempCanvas, 
        crop.x, crop.y, crop.w, crop.h, // Source (x,y,w,h)
        0, 0, crop.w, crop.h            // Dest (x,y,w,h)
      );
    }

    function nextSlide() {
      if(playIndex < allCroppings.length - 1) {
        playIndex++;
        renderSlide();
      }
    }
    
    function prevSlide() {
      if(playIndex > 0) {
        playIndex--;
        renderSlide();
      }
    }
    
    // Tap Zones (Left/Right)
    document.getElementById('performanceScreen').addEventListener('click', (e) => {
       if(e.clientX > window.innerWidth / 2) nextSlide();
       else prevSlide();
    });

  </script>
</body>
</html>
