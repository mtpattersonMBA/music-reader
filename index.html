<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Manual System Cropper</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* SHARED UTILS */
    .hidden { display: none !important; }
    
    .big-btn {
      background: #333;
      color: white;
      border: 1px solid #555;
      padding: 15px 30px;
      font-size: 1.2rem;
      border-radius: 8px;
      cursor: pointer;
      margin: 5px;
    }
    .primary-btn { background: #006600; border-color: #008800; font-weight: bold; }
    .danger-btn { background: #660000; border-color: #880000; }

    /* 1. UPLOAD SCREEN */
    #uploadScreen {
      padding: 30px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
    }

    /* 2. EDITOR SCREEN */
    #editorScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
      position: relative;
    }
    
    #editorHeader {
      height: 60px;
      background: #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 10px;
      border-bottom: 1px solid #444;
    }

    #editorCanvasContainer {
      flex: 1;
      overflow: auto;
      background: #333;
      position: relative;
      display: flex;
      justify-content: center;
      padding: 20px;
      touch-action: none; /* Critical for dragging on iPad */
    }
    
    #editorCanvas {
      box-shadow: 0 0 30px rgba(0,0,0,0.5);
      cursor: crosshair;
    }

    /* 3. PERFORMANCE SCREEN */
    #performanceScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #000;
    }
    
    #perfCanvasContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
    }
    
    #perfCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: #fff;
    }

    #controls {
      height: 15vh;
      display: flex;
      background: #111;
      border-top: 1px solid #333;
    }
    .nav-btn {
      flex: 1;
      font-size: 2.5rem;
      border: none;
      color: #fff;
      background: #222;
    }
    .nav-btn:active { background: #444; }

  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>Manual System Cropper</h1>
    <p style="color:#aaa; margin-bottom:20px;">
      Upload a PDF, then draw boxes around the systems yourself.<br>
      100% reliable because YOU define the music.
    </p>
    <input type="file" id="fileInput" accept="application/pdf" class="big-btn">
  </div>

  <div id="editorScreen" class="hidden">
    <div id="editorHeader">
      <div>
        <span id="pageIndicator" style="font-weight:bold; margin-right:10px;">Page 1</span>
        <button class="big-btn danger-btn" onclick="undoLastBox()" style="font-size:0.9rem; padding:8px 15px;">↩ Undo Box</button>
      </div>
      <div>
        <button class="big-btn" onclick="nextPage()">Next Page ➡️</button>
        <button class="big-btn primary-btn" onclick="finishEditing()">Start Playing ▶</button>
      </div>
    </div>
    
    <div id="editorCanvasContainer">
      <canvas id="editorCanvas"></canvas>
    </div>
  </div>

  <div id="performanceScreen" class="hidden">
    <div id="perfCanvasContainer">
      <canvas id="perfCanvas"></canvas>
    </div>
    <div id="controls">
      <button class="nav-btn" onclick="prevSystem()">⬅️</button>
      <button class="nav-btn" style="background:#004400;" onclick="nextSystem()">Next ➡️</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // SETUP
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // STATE
    let pdfDoc = null;
    let currentPageNum = 1;
    let scale = 1.5; // Editor view scale
    
    // "The Deck" - Array of { page: 1, x, y, w, h }
    let allCroppings = []; 
    // Temporary boxes for the current page only
    let pageBoxes = []; 

    // EDITOR DOM
    const editorCanvas = document.getElementById('editorCanvas');
    const ctx = editorCanvas.getContext('2d');
    
    // PERFORMANCE DOM
    const perfCanvas = document.getElementById('perfCanvas');
    const perfCtx = perfCanvas.getContext('2d');
    let currentPlayIndex = 0;

    // --- 1. UPLOAD LOGIC ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if(!file) return;

      const arrayBuffer = await file.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;

      document.getElementById('uploadScreen').classList.add('hidden');
      document.getElementById('editorScreen').classList.remove('hidden');

      loadEditorPage(1);
    });

    // --- 2. EDITOR LOGIC ---
    async function loadEditorPage(num) {
      if(num > pdfDoc.numPages) {
        finishEditing();
        return;
      }
      currentPageNum = num;
      pageBoxes = []; // Reset boxes for new page
      document.getElementById('pageIndicator').innerText = `Page ${num} / ${pdfDoc.numPages}`;

      const page = await pdfDoc.getPage(num);
      const viewport = page.getViewport({ scale: scale });

      editorCanvas.width = viewport.width;
      editorCanvas.height = viewport.height;
      
      // Render the PDF page to canvas
      await page.render({ canvasContext: ctx, viewport }).promise;
      
      // Save the "Clean" PDF image in memory so we can redraw it when dragging boxes
      // We use a hidden canvas or just toDataURL for simplicity in prototype
      editorCanvas.dataset.cleanImage = editorCanvas.toDataURL();
    }

    function redrawEditor() {
      const img = new Image();
      img.src = editorCanvas.dataset.cleanImage;
      img.onload = () => {
        ctx.clearRect(0,0, editorCanvas.width, editorCanvas.height);
        ctx.drawImage(img, 0, 0);
        
        // Draw existing boxes
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 3;
        ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
        
        pageBoxes.forEach((box, i) => {
          ctx.fillRect(box.x, box.y, box.w, box.h);
          ctx.strokeRect(box.x, box.y, box.w, box.h);
          
          // Number them
          ctx.fillStyle = "#00ff00";
          ctx.font = "20px Arial";
          ctx.fillText("#"+(allCroppings.length + i + 1), box.x + 5, box.y + 25);
          ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
        });

        // Draw current drag box
        if(isDragging) {
            const w = currentX - startX;
            const h = currentY - startY;
            ctx.fillStyle = "rgba(255, 255, 0, 0.3)"; // Yellow for active drag
            ctx.fillRect(startX, startY, w, h);
            ctx.strokeRect(startX, startY, w, h);
        }
      };
    }

    // --- MOUSE / TOUCH HANDLING FOR DRAWING ---
    let isDragging = false;
    let startX = 0, startY = 0;
    let currentX = 0, currentY = 0;

    function getPos(e) {
      const rect = editorCanvas.getBoundingClientRect();
      // Handle touch or mouse
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    // Start
    const startDraw = (e) => {
      e.preventDefault();
      const pos = getPos(e);
      startX = pos.x;
      startY = pos.y;
      isDragging = true;
    };

    // Move
    const moveDraw = (e) => {
      if(!isDragging) return;
      e.preventDefault();
      const pos = getPos(e);
      currentX = pos.x;
      currentY = pos.y;
      redrawEditor();
    };

    // End
    const endDraw = (e) => {
      if(!isDragging) return;
      isDragging = false;
      
      const w = currentX - startX;
      const h = currentY - startY;

      // Ignore tiny accidental clicks (< 20px)
      if(Math.abs(w) > 20 && Math.abs(h) > 20) {
        // Normalize (handle dragging backwards)
        const realX = w < 0 ? currentX : startX;
        const realY = h < 0 ? currentY : startY;
        const realW = Math.abs(w);
        const realH = Math.abs(h);

        pageBoxes.push({ x: realX, y: realY, w: realW, h: realH });
      }
      redrawEditor();
    };

    // Events
    editorCanvas.addEventListener('mousedown', startDraw);
    editorCanvas.addEventListener('mousemove', moveDraw);
    editorCanvas.addEventListener('mouseup', endDraw);
    
    editorCanvas.addEventListener('touchstart', startDraw);
    editorCanvas.addEventListener('touchmove', moveDraw);
    editorCanvas.addEventListener('touchend', endDraw);


    // --- EDITOR BUTTONS ---
    function undoLastBox() {
      pageBoxes.pop();
      redrawEditor();
    }

    function nextPage() {
      // Commit current page boxes to the Master List
      // We need to store them with the page number!
      pageBoxes.forEach(b => {
        allCroppings.push({
          pageNum: currentPageNum,
          x: b.x, y: b.y, w: b.w, h: b.h
        });
      });

      // Move on
      loadEditorPage(currentPageNum + 1);
    }

    function finishEditing() {
      // Commit any boxes on the current page before finishing
      pageBoxes.forEach(b => {
        allCroppings.push({
          pageNum: currentPageNum,
          x: b.x, y: b.y, w: b.w, h: b.h
        });
      });

      if(allCroppings.length === 0) {
        alert("You didn't draw any boxes!");
        return;
      }

      // Switch UI
      document.getElementById('editorScreen').classList.add('hidden');
      document.getElementById('performanceScreen').classList.remove('hidden');
      
      currentPlayIndex = 0;
      renderPerformanceSystem();
    }


    // --- 3. PERFORMANCE LOGIC ---
    async function renderPerformanceSystem() {
      const crop = allCroppings[currentPlayIndex];
      
      // We need to re-render the PDF page to get high-res crop
      // (Using the editor canvas image is blurry)
      const page = await pdfDoc.getPage(crop.pageNum);
      
      // Use the same scale we cropped with to match coordinates
      const viewport = page.getViewport({ scale: scale });
      
      // Create temp canvas to render full page
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      await page.render({ canvasContext: tempCtx, viewport }).promise;
      
      // Now draw just the crop to the performance canvas
      perfCanvas.width = crop.w;
      perfCanvas.height = crop.h;
      
      perfCtx.fillStyle = "white";
      perfCtx.fillRect(0,0, crop.w, crop.h);
      
      perfCtx.drawImage(
        tempCanvas,
        crop.x, crop.y, crop.w, crop.h, // Source
        0, 0, crop.w, crop.h // Dest
      );
    }

    function nextSystem() {
      if(currentPlayIndex < allCroppings.length - 1) {
        currentPlayIndex++;
        renderPerformanceSystem();
      }
    }
    
    function prevSystem() {
      if(currentPlayIndex > 0) {
        currentPlayIndex--;
        renderPerformanceSystem();
      }
    }

    // Keyboard / Click nav
    window.addEventListener('keydown', (e) => {
      if(e.key === "ArrowRight" || e.key === " ") nextSystem();
      if(e.key === "ArrowLeft") prevSystem();
    });
    
    document.getElementById('performanceScreen').addEventListener('click', (e) => {
      if(e.clientX > window.innerWidth / 2) nextSystem();
      else prevSystem();
    });

  </script>
</body>
</html>
