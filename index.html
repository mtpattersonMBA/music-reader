<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Accolade Hunter</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* UPLOAD SCREEN */
    #uploadScreen {
      padding: 30px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      background: #111;
    }

    .big-btn {
      background: #333;
      color: white;
      border: 2px solid #555;
      padding: 20px 40px;
      font-size: 1.5rem;
      border-radius: 15px;
      margin-top: 20px;
      cursor: pointer;
    }

    /* PERFORMANCE STAGE */
    #performanceMode {
      display: none;
      flex: 1;
      position: relative;
      flex-direction: column;
      height: 100%;
    }

    #canvasContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      overflow: hidden;
      padding: 10px;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain; 
      background: #fff;
      box-shadow: 0 0 20px rgba(255,255,255,0.1);
    }

    /* NAVIGATION BUTTONS */
    #controls {
      height: 20vh;
      display: flex;
      background: #111;
      border-top: 1px solid #333;
    }
    .nav-btn {
      flex: 1;
      font-size: 2.5rem;
      border: none;
      color: #fff;
      active: opacity: 0.7;
      cursor: pointer;
    }
    #prevBtn { background: #1a1a1a; border-right: 1px solid #333; }
    #nextBtn { background: #004400; font-weight: bold; }

    /* INFO OVERLAY */
    #sysInfo {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      pointer-events: none;
    }

    #loader {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 100;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>Choral Accolade Hunter</h1>
    <p style="color:#aaa; max-width:400px; line-height:1.5;">
      I will scan the <strong>left margin</strong> of your PDF looking for the vertical bracket (Accolade) to group systems automatically.
    </p>
    <input type="file" id="fileInput" accept="application/pdf" class="big-btn">
  </div>

  <div id="loader">
    <div style="font-size: 2rem; margin-bottom: 20px;">Scanning Margins...</div>
    <div style="color: #aaa;">Detecting vertical brackets</div>
  </div>

  <div id="performanceMode">
    <div id="sysInfo">System <span id="sysNum">1</span></div>
    
    <div id="canvasContainer">
      <canvas id="systemCanvas"></canvas>
    </div>
    
    <div id="controls">
      <button id="prevBtn" class="nav-btn" onclick="prevSystem()">⬅️</button>
      <button id="nextBtn" class="nav-btn" onclick="nextSystem()">Next ➡️</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // SETUP
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let allSystems = [];
    let currentSystemIndex = 0;
    const canvas = document.getElementById('systemCanvas');
    const ctx = canvas.getContext('2d');

    // FILE HANDLING
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      document.getElementById('loader').style.display = 'flex';
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        allSystems = []; 
        
        for (let p = 1; p <= pdf.numPages; p++) {
          await processPage(pdf, p);
        }

        if (allSystems.length === 0) {
          alert("No brackets found! Is this a choral score?");
          location.reload();
          return;
        }

        document.getElementById('loader').style.display = 'none';
        document.getElementById('uploadScreen').style.display = 'none';
        document.getElementById('performanceMode').style.display = 'flex';
        
        currentSystemIndex = 0;
        renderSystem();

      } catch (err) {
        console.error(err);
        alert("Error: " + err.message);
        document.getElementById('loader').style.display = 'none';
      }
    });

    // THE ACCOLADE HUNTER ALGORITHM
    async function processPage(pdf, pageNum) {
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale: 2.0 }); 
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      // GET PIXEL DATA
      const width = tempCanvas.width;
      const height = tempCanvas.height;
      const imageData = tempCtx.getImageData(0, 0, width, height).data;

      // STRATEGY: Scan only the LEFT 15% of the page.
      // We look for rows that have "ink" in the margin.
      // A continuous run of rows with ink = ONE BRACKET = ONE SYSTEM.
      
      const MARGIN_RIGHT_BOUNDARY = Math.floor(width * 0.15); // Scan first 15% width
      const INK_THRESHOLD = 3; // Need at least 3 dark pixels in the margin to count as 'bracket'
      
      let rowHasBracket = new Array(height).fill(false);
      
      for (let y = 0; y < height; y++) {
        let darkPixels = 0;
        // Optimization: Check every 2nd pixel in margin
        for (let x = 0; x < MARGIN_RIGHT_BOUNDARY; x += 2) {
          const i = (y * width + x) * 4;
          // If dark
          if (imageData[i] < 200) {
             darkPixels++;
             if(darkPixels >= INK_THRESHOLD) {
               rowHasBracket[y] = true;
               break; // Found ink, move to next row
             }
          }
        }
      }

      // GROUPING LOGIC
      // We now have an array [true, true, true, false, false...] representing the bracket
      // 'true' means we are inside a bracket height.
      
      let inSystem = false;
      let startY = 0;
      
      // Smoothing: Ignore tiny gaps (scanned broken lines) of < 10px
      let gapCounter = 0; 
      const GAP_TOLERANCE = 10; 

      for (let y = 0; y < height; y++) {
        if (rowHasBracket[y]) {
          if (!inSystem) {
            inSystem = true;
            startY = y;
          }
          gapCounter = 0;
        } else {
          // No bracket ink here
          if (inSystem) {
            gapCounter++;
            if (gapCounter > GAP_TOLERANCE) {
              // Real gap found, close the system
              inSystem = false;
              let endY = y - gapCounter;
              
              // Filter out noise (must be > 50px tall to be a system)
              if ((endY - startY) > 50) {
                allSystems.push({
                  sourceCanvas: tempCanvas,
                  y: Math.max(0, startY - 20), // Add padding
                  h: (endY - startY) + 40,
                  w: width
                });
              }
            }
          }
        }
      }
      
      // Capture last system if page ends
      if (inSystem) {
         let endY = height;
         if ((endY - startY) > 50) {
            allSystems.push({
               sourceCanvas: tempCanvas,
               y: Math.max(0, startY - 20),
               h: (endY - startY) + 20,
               w: width
            });
         }
      }
    }

    // RENDERER
    function renderSystem() {
      if (!allSystems[currentSystemIndex]) return;
      const sys = allSystems[currentSystemIndex];
      document.getElementById('sysNum').innerText = `${currentSystemIndex + 1} / ${allSystems.length}`;

      canvas.width = sys.w;
      canvas.height = sys.h;

      ctx.fillStyle = "white";
      ctx.fillRect(0,0, canvas.width, canvas.height);
      ctx.drawImage(
        sys.sourceCanvas,
        0, sys.y, sys.w, sys.h, 
        0, 0, sys.w, sys.h
      );
    }

    function nextSystem() {
      if (currentSystemIndex < allSystems.length - 1) {
        currentSystemIndex++;
        renderSystem();
      }
    }
    function prevSystem() {
      if (currentSystemIndex > 0) {
        currentSystemIndex--;
        renderSystem();
      }
    }
    
    window.addEventListener('keydown', (e) => {
      if (e.key === "ArrowRight" || e.key === " ") nextSystem();
      if (e.key === "ArrowLeft") prevSystem();
    });

    document.getElementById('canvasContainer').addEventListener('click', (e) => {
      if(e.clientX > window.innerWidth / 2) nextSystem();
      else prevSystem();
    });
  </script>
</body>
</html>
