<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Hybrid Smart-Slicer</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #uploadScreen {
      padding: 30px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      background: #111;
    }

    .big-btn {
      background: #333;
      color: white;
      border: 2px solid #555;
      padding: 20px 40px;
      font-size: 1.5rem;
      border-radius: 15px;
      margin-top: 20px;
      cursor: pointer;
    }

    #performanceMode {
      display: none;
      flex: 1;
      position: relative;
      flex-direction: column;
      height: 100%;
    }

    #canvasContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      overflow: hidden;
      padding: 10px;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain; 
      background: #fff;
    }

    #controls {
      height: 20vh;
      display: flex;
      background: #111;
      border-top: 1px solid #333;
    }
    .nav-btn {
      flex: 1;
      font-size: 2.5rem;
      border: none;
      color: #fff;
    }
    #prevBtn { background: #1a1a1a; }
    #nextBtn { background: #004400; font-weight: bold; }

    #sysInfo {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      pointer-events: none;
    }

    #loader {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 100;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>Hybrid Smart-Slicer</h1>
    <p style="color:#aaa; max-width:400px; line-height:1.5;">
      Combines "Vertical Spine" detection (for big systems) with "Ink Density" (for solos/unison).
    </p>
    <input type="file" id="fileInput" accept="application/pdf" class="big-btn">
  </div>

  <div id="loader">
    <div style="font-size: 2rem; margin-bottom: 20px;">Thinking...</div>
    <div style="color: #aaa;">Scanning spines & bridging gaps</div>
  </div>

  <div id="performanceMode">
    <div id="sysInfo">System <span id="sysNum">1</span></div>
    <div id="canvasContainer">
      <canvas id="systemCanvas"></canvas>
    </div>
    <div id="controls">
      <button id="prevBtn" class="nav-btn" onclick="prevSystem()">⬅️</button>
      <button id="nextBtn" class="nav-btn" onclick="nextSystem()">Next ➡️</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let allSystems = [];
    let currentSystemIndex = 0;
    const canvas = document.getElementById('systemCanvas');
    const ctx = canvas.getContext('2d');

    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      document.getElementById('loader').style.display = 'flex';
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        allSystems = []; 
        for (let p = 1; p <= pdf.numPages; p++) {
          await processPage(pdf, p);
        }

        if (allSystems.length === 0) {
          alert("No music found. Try a different PDF.");
          location.reload();
          return;
        }

        document.getElementById('loader').style.display = 'none';
        document.getElementById('uploadScreen').style.display = 'none';
        document.getElementById('performanceMode').style.display = 'flex';
        currentSystemIndex = 0;
        renderSystem();
      } catch (err) {
        console.error(err);
        alert("Error: " + err.message);
      }
    });

    async function processPage(pdf, pageNum) {
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale: 2.0 });
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      const width = tempCanvas.width;
      const height = tempCanvas.height;
      const imageData = tempCtx.getImageData(0, 0, width, height).data;

      // --- PHASE 1: MAPPING THE "SPINES" (Vertical Connectors) ---
      // We look for vertical runs > 60px. These force connection.
      let rowHasSpine = new Array(height).fill(false);
      const MIN_SPINE_HEIGHT = 60; // Lowered to catch smaller brackets too

      for (let x = 0; x < width; x += 5) {
        let currentRun = 0;
        for (let y = 0; y < height; y++) {
          const i = (y * width + x) * 4;
          if (imageData[i] < 200) {
             currentRun++;
          } else {
             if (currentRun > MIN_SPINE_HEIGHT) {
                for (let k = y - currentRun; k < y; k++) rowHasSpine[k] = true;
             }
             currentRun = 0;
          }
        }
        if (currentRun > MIN_SPINE_HEIGHT) {
           for (let k = height - currentRun; k < height; k++) rowHasSpine[k] = true;
        }
      }

      // --- PHASE 2: MAPPING THE "INK" (Horizontal Content) ---
      // We look for any row that has significant dark pixels.
      let rowHasInk = new Array(height).fill(false);
      
      // Scan middle 50% of page width
      const startX = Math.floor(width * 0.25);
      const endX = Math.floor(width * 0.75);
      
      for (let y = 0; y < height; y++) {
        let darkPixels = 0;
        for (let x = startX; x < endX; x += 5) {
           const i = (y * width + x) * 4;
           if (imageData[i] < 200) darkPixels++;
        }
        if (darkPixels > 5) rowHasInk[y] = true;
      }

      // --- PHASE 3: THE HYBRID MERGE ---
      let inSystem = false;
      let startY = 0;
      let gapCounter = 0;
      
      // SOLO GAP TOLERANCE: If no spine, we allow a small gap (e.g. 50px)
      // before declaring the system over.
      const MAX_SOLO_GAP = 50; 

      for (let y = 0; y < height; y++) {
        
        // CONDITION A: We see a Spine (Strongest Signal)
        // CONDITION B: We see Ink (Weaker Signal)
        const isSpine = rowHasSpine[y];
        const isInk = rowHasInk[y];
        
        const isActive = isSpine || isInk;

        if (isActive) {
          if (!inSystem) {
            inSystem = true;
            startY = y;
          }
          // We are in active territory, so reset gap counter
          gapCounter = 0;
          
        } else {
          // We are in white space
          if (inSystem) {
            
            // SPECIAL CHECK:
            // If the PREVIOUS active area was a Spine, we are stricter about closing it?
            // Actually, simpler:
            // If we hit white space, we increment counter.
            // But if we are currently "inside" a bracket physically, 'rowHasSpine[y]' would be true.
            // Since it is FALSE here, we are truly in a gap (either between staves or systems).
            
            gapCounter++;
            
            if (gapCounter > MAX_SOLO_GAP) {
               // We have exceeded the gap limit.
               // CLOSE THE SYSTEM.
               inSystem = false;
               let endY = y - gapCounter;
               
               // Validation: Must be > 60px tall
               if ((endY - startY) > 60) {
                 allSystems.push({
                   sourceCanvas: tempCanvas,
                   y: Math.max(0, startY - 30),
                   h: (endY - startY) + 60,
                   w: width
                 });
               }
            }
          }
        }
      }
      
      // Catch last
      if (inSystem) {
         let endY = height;
         if ((endY - startY) > 60) {
            allSystems.push({
               sourceCanvas: tempCanvas,
               y: Math.max(0, startY - 30),
               h: (endY - startY) + 60,
               w: width
            });
         }
      }
    }

    function renderSystem() {
      if (!allSystems[currentSystemIndex]) return;
      const sys = allSystems[currentSystemIndex];
      document.getElementById('sysNum').innerText = `${currentSystemIndex + 1} / ${allSystems.length}`;

      canvas.width = sys.w;
      canvas.height = sys.h;
      ctx.fillStyle = "white";
      ctx.fillRect(0,0, canvas.width, canvas.height);
      ctx.drawImage(sys.sourceCanvas, 0, sys.y, sys.w, sys.h, 0, 0, sys.w, sys.h);
    }

    function nextSystem() {
      if (currentSystemIndex < allSystems.length - 1) {
        currentSystemIndex++;
        renderSystem();
      }
    }
    function prevSystem() {
      if (currentSystemIndex > 0) {
        currentSystemIndex--;
        renderSystem();
      }
    }
    
    window.addEventListener('keydown', (e) => {
      if (e.key === "ArrowRight" || e.key === " ") nextSystem();
      if (e.key === "ArrowLeft") prevSystem();
    });
    
    document.getElementById('canvasContainer').addEventListener('click', (e) => {
      if(e.clientX > window.innerWidth / 2) nextSystem();
      else prevSystem();
    });
  </script>
</body>
</html>
