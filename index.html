<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Precision Cropper: Re-Editable</title>
  <style>
    /* 1. RESET & LAYOUT */
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden; 
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .hidden { display: none !important; }

    /* 2. UPLOAD SCREEN */
    #uploadScreen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      text-align: center;
    }
    .big-file-btn {
      margin-top: 20px;
      padding: 15px;
      background: #333;
      border: 2px dashed #666;
      color: #fff;
      border-radius: 10px;
    }

    /* 3. EDITOR SCREEN */
    #editorScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #editorToolbar {
      height: 60px;
      background: #222;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 10px;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }

    .tool-group { display: flex; gap: 8px; align-items: center; }
    
    .tool-btn {
      background: #444;
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
    }
    .primary-btn { background: #0066cc; }
    .success-btn { background: #008800; }
    .danger-btn { background: #880000; }
    
    #editorScrollArea {
      flex: 1;
      overflow: auto;
      position: relative;
      background: #333;
      touch-action: pan-y; 
    }

    #editorCanvas {
      display: block;
      margin: 0 auto;
      background: white;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      touch-action: none; 
    }

    /* 4. PERFORMANCE SCREEN */
    #performanceScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
      background: #000;
      position: relative;
    }
    
    #slideContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
    }
    
    #slideCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      background: white; 
    }

    #navControls {
      height: 15vh;
      display: flex;
      background: #111;
      border-top: 1px solid #333;
    }
    .nav-btn {
      flex: 1;
      font-size: 2rem;
      background: #111;
      color: #fff;
      border: none;
      border-right: 1px solid #333;
    }
    .nav-btn:active { background: #222; }

    /* The "Edit" button in player mode */
    #editModeBtn {
      position: absolute;
      top: 20px; left: 20px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 1px solid #555;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 1rem;
      z-index: 200;
      cursor: pointer;
    }

  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>Music System Cropper</h1>
    <p style="color:#aaa;">Upload &rarr; Draw &rarr; Play &rarr; Edit</p>
    <input type="file" id="fileInput" accept="application/pdf" class="big-file-btn">
  </div>

  <div id="editorScreen" class="hidden">
    <div id="editorToolbar">
      <div class="tool-group">
        <button class="tool-btn" onclick="prevPage()">&larr;</button>
        <span id="pageInfo" style="font-weight:bold; font-size:0.9rem;">Pg 1</span>
        <button class="tool-btn" onclick="nextPage()">&rarr;</button>
      </div>

      <div class="tool-group">
        <button class="tool-btn danger-btn" onclick="undoBox()">Undo</button>
        <button class="tool-btn success-btn" onclick="goToPlayer()">Play &#9658;</button>
      </div>
    </div>
    <div id="editorScrollArea">
      <canvas id="editorCanvas"></canvas>
    </div>
  </div>

  <div id="performanceScreen" class="hidden">
    <button id="editModeBtn" onclick="returnToEditor()">&#9998; Edit Boxes</button>
    
    <div id="slideContainer">
      <canvas id="slideCanvas"></canvas>
    </div>
    
    <div id="navControls">
      <button class="nav-btn" onclick="prevSlide()">&#8592;</button>
      <button class="nav-btn" onclick="nextSlide()" style="background:#003300; font-weight:bold;">Next &#8594;</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // --- 1. SETUP ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    let pdfDoc = null;
    let currentPage = 1;
    
    // STATE: "masterBoxList" stores boxes for ALL pages
    // Structure: { 1: [box, box], 2: [box] }
    let masterBoxList = {}; 
    let currentBoxes = []; // Temp holder for the active page
    
    // Player State
    let playbackList = []; // Flattened list for the player
    let playIndex = 0;

    // DOM
    const editorCanvas = document.getElementById('editorCanvas');
    const ctx = editorCanvas.getContext('2d');
    const slideCanvas = document.getElementById('slideCanvas');
    const slideCtx = slideCanvas.getContext('2d');

    // --- 2. UPLOAD ---
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if(!file) return;

      const buffer = await file.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument(buffer).promise;

      document.getElementById('uploadScreen').classList.add('hidden');
      document.getElementById('editorScreen').classList.remove('hidden');
      
      loadEditorPage(1);
    });

    // --- 3. EDITOR CORE ---
    async function loadEditorPage(num) {
      if(num < 1 || num > pdfDoc.numPages) return;

      // 1. Save current work before switching
      saveCurrentPageToMaster();

      currentPage = num;
      document.getElementById('pageInfo').innerText = `Pg ${num} / ${pdfDoc.numPages}`;

      // 2. Load boxes from memory if they exist
      if(masterBoxList[num]) {
        // Create a deep copy so we don't mutate master directly until save
        currentBoxes = JSON.parse(JSON.stringify(masterBoxList[num]));
      } else {
        currentBoxes = [];
      }

      // 3. Render PDF
      const page = await pdfDoc.getPage(num);
      const viewport = page.getViewport({ scale: 1.5 });

      editorCanvas.width = viewport.width;
      editorCanvas.height = viewport.height;
      
      await page.render({ canvasContext: ctx, viewport }).promise;

      // Save background for efficient redraws
      editorCanvas.dataset.clean = editorCanvas.toDataURL();
      
      // Draw existing boxes (if we went back to this page)
      redraw();
    }

    function saveCurrentPageToMaster() {
      // Save the current state of boxes to the master list
      if(currentBoxes.length > 0) {
        masterBoxList[currentPage] = JSON.parse(JSON.stringify(currentBoxes));
      } else {
        delete masterBoxList[currentPage]; // Cleanup empty pages
      }
    }

    function redraw() {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0,0, editorCanvas.width, editorCanvas.height);
        ctx.drawImage(img, 0, 0);

        // Draw saved boxes
        currentBoxes.forEach((box, i) => {
          ctx.strokeStyle = '#00ff00';
          ctx.lineWidth = 3;
          ctx.strokeRect(box.x, box.y, box.w, box.h);
          ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
          ctx.fillRect(box.x, box.y, box.w, box.h);
          
          // Number
          ctx.fillStyle = '#000';
          ctx.fillRect(box.x, box.y, 20, 20);
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 14px Arial';
          ctx.fillText(i+1, box.x+5, box.y+15);
        });

        // Draw Active Drag
        if(isDragging) {
           const w = currentX - startX;
           const h = currentY - startY;
           ctx.strokeStyle = 'yellow';
           ctx.lineWidth = 2;
           ctx.strokeRect(startX, startY, w, h);
        }
      };
      img.src = editorCanvas.dataset.clean;
    }

    // --- 4. TOUCH LOGIC (Precision Fixed) ---
    let isDragging = false;
    let startX = 0, startY = 0;
    let currentX = 0, currentY = 0;

    function getPos(e) {
      const rect = editorCanvas.getBoundingClientRect();
      let cx = e.clientX;
      let cy = e.clientY;
      if(e.changedTouches && e.changedTouches.length > 0) {
        cx = e.changedTouches[0].clientX;
        cy = e.changedTouches[0].clientY;
      }
      const scaleX = editorCanvas.width / rect.width;
      const scaleY = editorCanvas.height / rect.height;
      return { x: (cx - rect.left) * scaleX, y: (cy - rect.top) * scaleY };
    }

    const startDraw = (e) => {
      if(e.touches && e.touches.length > 1) return;
      if(e.target !== editorCanvas) return;
      e.preventDefault(); 
      const pos = getPos(e);
      startX = pos.x; startY = pos.y;
      isDragging = true;
    };

    const moveDraw = (e) => {
      if(!isDragging) return;
      e.preventDefault(); 
      const pos = getPos(e);
      currentX = pos.x; currentY = pos.y;
      redraw();
    };

    const endDraw = (e) => {
      if(!isDragging) return;
      e.preventDefault();
      isDragging = false;
      const pos = getPos(e);
      currentX = pos.x; currentY = pos.y;
      
      const w = currentX - startX;
      const h = currentY - startY;

      if(Math.abs(w) > 20 && Math.abs(h) > 20) {
        const finalX = w < 0 ? currentX : startX;
        const finalY = h < 0 ? currentY : startY;
        const finalW = Math.abs(w);
        const finalH = Math.abs(h);
        currentBoxes.push({ x: finalX, y: finalY, w: finalW, h: finalH });
      }
      redraw();
    };
    
    editorCanvas.addEventListener('dblclick', (e) => {
       const pos = getPos(e);
       for(let i = currentBoxes.length - 1; i >= 0; i--) {
         const b = currentBoxes[i];
         if(pos.x >= b.x && pos.x <= b.x + b.w && pos.y >= b.y && pos.y <= b.y + b.h) {
           currentBoxes.splice(i, 1);
           redraw();
           break;
         }
       }
    });

    editorCanvas.addEventListener('mousedown', startDraw);
    editorCanvas.addEventListener('mousemove', moveDraw);
    editorCanvas.addEventListener('mouseup', endDraw);
    editorCanvas.addEventListener('touchstart', startDraw, {passive: false});
    editorCanvas.addEventListener('touchmove', moveDraw, {passive: false});
    editorCanvas.addEventListener('touchend', endDraw, {passive: false});


    // --- 5. NAVIGATION & ACTIONS ---
    function undoBox() {
      currentBoxes.pop();
      redraw();
    }

    function prevPage() {
      if(currentPage > 1) loadEditorPage(currentPage - 1);
    }
    
    function nextPage() {
      if(currentPage < pdfDoc.numPages) loadEditorPage(currentPage + 1);
    }

    function goToPlayer() {
      saveCurrentPageToMaster();

      // Flatten Master List into a Playable Array
      playbackList = [];
      // Iterate through pages 1 to TotalPages to keep order
      for(let p = 1; p <= pdfDoc.numPages; p++) {
        if(masterBoxList[p]) {
          masterBoxList[p].forEach(box => {
            playbackList.push({ pageNum: p, ...box });
          });
        }
      }

      if(playbackList.length === 0) {
        alert("No boxes drawn yet!");
        return;
      }

      // Switch Screens
      document.getElementById('editorScreen').classList.add('hidden');
      document.getElementById('performanceScreen').classList.remove('hidden');
      
      // Start from beginning? Or stay where we were? 
      // Let's start from 0 for simplicity, or keep index if robust.
      // Resetting to 0 avoids out-of-bounds errors.
      playIndex = 0;
      renderSlide();
    }

    function returnToEditor() {
      document.getElementById('performanceScreen').classList.add('hidden');
      document.getElementById('editorScreen').classList.remove('hidden');
      
      // Optional: Jump editor to the page of the current slide
      if(playbackList[playIndex]) {
        loadEditorPage(playbackList[playIndex].pageNum);
      } else {
        loadEditorPage(currentPage);
      }
    }

    // --- 6. PLAYER ENGINE ---
    async function renderSlide() {
      const crop = playbackList[playIndex];
      const page = await pdfDoc.getPage(crop.pageNum);
      const viewport = page.getViewport({ scale: 1.5 });

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      slideCanvas.width = crop.w;
      slideCanvas.height = crop.h;
      
      slideCtx.fillStyle = "white";
      slideCtx.fillRect(0,0, crop.w, crop.h);
      slideCtx.drawImage(tempCanvas, crop.x, crop.y, crop.w, crop.h, 0, 0, crop.w, crop.h);
    }

    function nextSlide() {
      if(playIndex < playbackList.length - 1) {
        playIndex++;
        renderSlide();
      }
    }
    
    function prevSlide() {
      if(playIndex > 0) {
        playIndex--;
        renderSlide();
      }
    }
    
    document.getElementById('performanceScreen').addEventListener('click', (e) => {
       // Ignore clicks on the "Edit" button
       if(e.target.id === 'editModeBtn') return;
       
       if(e.clientX > window.innerWidth / 2) nextSlide();
       else prevSlide();
    });
    
    // Keyboard
    window.addEventListener('keydown', (e) => {
      if(e.key === "ArrowRight" || e.key === " ") nextSlide();
      if(e.key === "ArrowLeft") prevSlide();
    });

  </script>
</body>
</html>
