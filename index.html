<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>The Calibrated Slicer</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* UPLOAD SCREEN */
    #uploadScreen {
      padding: 30px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      background: #111;
    }

    .control-group {
      margin: 20px 0;
      width: 80%;
      max-width: 400px;
      text-align: left;
      background: #222;
      padding: 20px;
      border-radius: 10px;
    }

    label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 1.1rem;
      color: #fff;
    }
    
    input[type="range"] {
      width: 100%;
      height: 30px;
      accent-color: #00ff00;
      cursor: pointer;
    }

    .big-btn {
      background: #333;
      color: white;
      border: 2px solid #555;
      padding: 20px 40px;
      font-size: 1.5rem;
      border-radius: 15px;
      margin-top: 20px;
      cursor: pointer;
    }

    /* PERFORMANCE STAGE */
    #performanceMode {
      display: none;
      flex: 1;
      position: relative;
      flex-direction: column;
      height: 100%;
    }

    #canvasContainer {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
      overflow: hidden;
      padding: 10px;
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain; 
      background: #fff;
      box-shadow: 0 0 20px rgba(255,255,255,0.1);
    }

    /* NAVIGATION BUTTONS */
    #controls {
      height: 20vh;
      display: flex;
      background: #111;
      border-top: 1px solid #333;
    }
    .nav-btn {
      flex: 1;
      font-size: 2.5rem;
      border: none;
      color: #fff;
      active: opacity: 0.7;
      cursor: pointer;
    }
    #prevBtn { background: #1a1a1a; border-right: 1px solid #333; }
    #nextBtn { background: #004400; font-weight: bold; }

    /* INFO OVERLAY */
    #sysInfo {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      pointer-events: none;
    }

    #loader {
      display: none;
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      z-index: 100;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>
<body>

  <div id="uploadScreen">
    <h1>The Calibrated Slicer</h1>
    
    <div class="control-group">
      <label>
        <span>Gap Tolerance</span>
        <span id="valDisplay" style="color:#00ff00">50px</span>
      </label>
      <input type="range" id="gapSlider" min="20" max="150" value="50" step="5" oninput="updateLabel(this.value)">
      <p style="color:#aaa; font-size:0.9rem; margin-top:10px;">
        <strong>Slide Left:</strong> If seeing whole pages (System gap is small).<br>
        <strong>Slide Right:</strong> If seeing single staves (Part gap is big).
      </p>
    </div>

    <input type="file" id="fileInput" accept="application/pdf" class="big-btn">
  </div>

  <div id="loader">
    <div style="font-size: 2rem; margin-bottom: 20px;">Analyzing...</div>
    <div style="color: #aaa;">Scanning center & bridging gaps</div>
  </div>

  <div id="performanceMode">
    <div id="sysInfo">System <span id="sysNum">1</span></div>
    
    <div id="canvasContainer">
      <canvas id="systemCanvas"></canvas>
    </div>
    
    <div id="controls">
      <button id="prevBtn" class="nav-btn" onclick="prevSystem()">⬅️</button>
      <button id="nextBtn" class="nav-btn" onclick="nextSystem()">Next ➡️</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <script>
    // SETUP
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let allSystems = [];
    let currentSystemIndex = 0;
    const canvas = document.getElementById('systemCanvas');
    const ctx = canvas.getContext('2d');

    // UI UPDATES
    function updateLabel(val) {
      document.getElementById('valDisplay').innerText = val + "px";
    }

    // FILE HANDLING
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const gapTolerance = parseInt(document.getElementById('gapSlider').value);
      
      document.getElementById('loader').style.display = 'flex';
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        
        allSystems = []; 
        
        for (let p = 1; p <= pdf.numPages; p++) {
          await processPage(pdf, p, gapTolerance);
        }

        if (allSystems.length === 0) {
          alert("No music found! Try adjusting the slider.");
          location.reload();
          return;
        }

        document.getElementById('loader').style.display = 'none';
        document.getElementById('uploadScreen').style.display = 'none';
        document.getElementById('performanceMode').style.display = 'flex';
        
        currentSystemIndex = 0;
        renderSystem();

      } catch (err) {
        console.error(err);
        alert("Error: " + err.message);
        document.getElementById('loader').style.display = 'none';
      }
    });

    // THE CALIBRATED "SQUINT" ALGORITHM
    async function processPage(pdf, pageNum, gapTolerance) {
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale: 2.0 }); 
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      const width = tempCanvas.width;
      const height = tempCanvas.height;
      const imageData = tempCtx.getImageData(0, 0, width, height).data;

      // STEP 1: Scan Center (25% - 75%)
      const START_X = Math.floor(width * 0.25);
      const END_X = Math.floor(width * 0.75);
      
      let rowDensity = new Array(height).fill(0);
      
      for (let y = 0; y < height; y++) {
        let darkPixels = 0;
        for (let x = START_X; x < END_X; x += 5) { 
          const i = (y * width + x) * 4;
          if (imageData[i] < 200) darkPixels++; 
        }
        rowDensity[y] = darkPixels;
      }

      // STEP 2: Gap Logic with Slider Value
      const MIN_INK = 5; 

      let inSystem = false;
      let startY = 0;
      let whiteSpaceCounter = 0;

      for (let y = 0; y < height; y++) {
        const hasInk = rowDensity[y] > MIN_INK;

        if (hasInk) {
          if (!inSystem) {
            inSystem = true;
            startY = y;
          }
          whiteSpaceCounter = 0; 
        } else {
          // No ink here
          if (inSystem) {
            whiteSpaceCounter++;
            
            // Only cut if gap > gapTolerance (Slider Value)
            if (whiteSpaceCounter > gapTolerance) {
              
              inSystem = false;
              let endY = y - whiteSpaceCounter;
              
              // Validation: Block must be > 60px tall to be a system
              // (Slightly reduced min-height to catch smaller systems if needed)
              if ((endY - startY) > 60) {
                allSystems.push({
                  sourceCanvas: tempCanvas,
                  y: Math.max(0, startY - 20), // Padding
                  h: (endY - startY) + 40,
                  w: width
                });
              }
            }
          }
        }
      }
      
      if (inSystem) {
         let endY = height;
         if ((endY - startY) > 60) {
            allSystems.push({
               sourceCanvas: tempCanvas,
               y: Math.max(0, startY - 20),
               h: (endY - startY) + 40,
               w: width
            });
         }
      }
    }

    // RENDERER
    function renderSystem() {
      if (!allSystems[currentSystemIndex]) return;
      const sys = allSystems[currentSystemIndex];
      document.getElementById('sysNum').innerText = `${currentSystemIndex + 1} / ${allSystems.length}`;

      canvas.width = sys.w;
      canvas.height = sys.h;

      ctx.fillStyle = "white";
      ctx.fillRect(0,0, canvas.width, canvas.height);
      ctx.drawImage(
        sys.sourceCanvas,
        0, sys.y, sys.w, sys.h, 
        0, 0, sys.w, sys.h
      );
    }

    function nextSystem() {
      if (currentSystemIndex < allSystems.length - 1) {
        currentSystemIndex++;
        renderSystem();
      }
    }
    function prevSystem() {
      if (currentSystemIndex > 0) {
        currentSystemIndex--;
        renderSystem();
      }
    }
    
    window.addEventListener('keydown', (e) => {
      if (e.key === "ArrowRight" || e.key === " ") nextSystem();
      if (e.key === "ArrowLeft") prevSystem();
    });

    document.getElementById('canvasContainer').addEventListener('click', (e) => {
      if(e.clientX > window.innerWidth / 2) nextSystem();
      else prevSystem();
    });
  </script>
</body>
</html>
